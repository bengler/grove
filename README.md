# Grove

[![Build Status](https://semaphoreapp.com/api/v1/projects/35b20ab7aed8961031350862490b0bc555b9d6dc/28279/badge.png)](https://semaphoreapp.com/projects/1580/branches/28279)

Grove is a generic document store layered on top of an actual database such as PostgreSQL. It can store and index structured documents like comments, blog posts, events etc. and organize these documents for easy retrieval later.

## Data model

A Grove document is any dictionary-type object that can be represented with a JSON hash, including nested hashes. In addition to the content, a document has the following features:

* **ID** — every document has a unique ID ("uid").
* **Class** — every document has a class which indicates the type of document, typically being application-specific.
* **Paths** — every document must be associated with at least one path, forming a hierarchy. The paths are used for retrival.
* **Tags** — documents can be tagged.
* **Timestamps** — documents can fit on a timeline.

### Document class

An application specific class. This can be used to filter queries, and is typically used by applications to determine the content type of the document.

A class name is a **period-delimited string of identifiers** The first identifier must be "post" which indicates to the Pebbles ecology that this specific object is handled by Grove. Typical class names include:

- `post.blog`
- `post.event`
- `post.user_profile`

When retrieving a collection of object of disparate types, the class helps the application determine how to display and handle the document.

### Paths

Grove's document database can be viewed as a hierarchy of folders. Every document must be associated with at least one path. Paths with wildcards are typically used to query Grove for content.

A path is a period delimited string of identifiers where the first identifier must be the *realm* of the document (see [Checkpoint](http://github.com/bengler/checkpoint) for more on realms). The second identifier is by convention an application identifier, while the rest of the path is application specific.

Examples of paths:

- `acmecorp.calendarapp.events.facebook`
- `acmecorp.blogs.postings`
- `acmecorp.blogs.football.postings`
- `acmecorp.users`

A document has one canonical path, which is where the "original" document is stored. If you need the document to appear in multiple places in the folder hierarchy you may create "symlinks" by appending additional paths to the document. This will make the document appear in query results as if it were stored in all the provided paths, but in reality the original document is always returned. If the underlying document is updated, it will be updated for all paths.

You don't have to create "folders" in Grove. Any path you postulate is okay as long as it is within the _realm_ of your application.

#### A note on "subpaths"

It is a convention in Pebbles applications to put children of an object in a "subfolder" of its canonical path. A subpath is generated by appending the ID of the parent object to the path and storing the children there.

For example, a posting in the football blog (object ID = 323):

    post.blog:acmecorp.blogs.football$323

A comment to the posting (ID appended to path):

    post.comment:acmecorp.blogs.football.323$324

A later comment to the same posting:

    post.comment:acmecorp.blogs.football.323$5343

### Tags

A set og tags may be applied to any document and subsequently be used to constrain results in queries. A tag is a string that may contain letters, digits and underscores.

### Occurrences

A document may also be organized on a timeline. A document may have any number of timestamps (occurrences) attached to it. Each timestamp is labeled. This can be used to model start-/end-times for events, or due dates for tasks.

When querying Grove, the result set can be constrained to documents with a specific labeled occurrence and optionally only documents with such an occurrence within a specified time window. This would typically be used to retrieve events that occur on a specific date, or tasks that are overdue.

### Synchronization from external sources

When synchronizing data from external sources, you should give the document an `external_id`. The external ID may be any string, it may e.g. be the URL or database ID of the source object. The important thing is that it is invariant for the given source object, and that it is unique within the realm of your application. This ensures that updates written by multiple concurrent workers never results in duplicates.

Additionally Grove has a concept of `external_documents`. If the content of the source document is synchronized to Grove as an `external_document` (not `document`) and local edits are written to the `document` field Grove ensures that consecutive synchronization operations will not overwrite local edits, while fields that do not have local edits will still be updated from source. An example:

- An event is synchronized from facebook to Grove. The fields are written to the `external_document`, `document` is blank.
- An editor determines that the title of the event is unhelpful ("Big Launch!!!") and creates a local edit writing `{"title": "Launch of the new Wagner Niebelung Ring Lego Kits!!!"}`
- The document now contains the key `title` while the rest of the content is in `external_document`.
- A client requesting the document will see the merged content of `external_document` and `document`.
- An updated event is synchronized from facebook. The updated document is written to `external_document`. The body and title of the source document has been updated from the source.
- A client requesting the document sees the updated body, while the title is overridden by the content of document.
- Since the external_document is newer than the document and an updated field is overridden the document is now marked as "conflicted" in Grove. An application may provide an interface to the user to resolve this conflict and update the `document`.

### UID

Across all pebbles Grove documents are identified by their UIDs. The UID of a Grove document always has base class "post". UIDs have the format:

    <klass>:<canonical path>$<id>

Typical UIDs will look like this:

- `post.event:acmecorp.calendarapp.events.facebook$121`
- `post.comment:acmecorp.blogs.fotball.postings.121$453211`

## Custom policies

Grove supports Checkpoint callbacks. You may override Grove's internal rules about who has permissions to create, update and delete what by implementing callbacks. See [Checkpoint's documentation](https://github.com/bengler/checkpoint/blob/master/README.md) for details on how to do this.
